-- symbols are converted to camel case which is mandatory for Haskell

-- symbols in lowercase here are prefixed with "parse" in Haskell
-- symbols in uppercase here are prefixed with "parseToken" in Haskell

-- the type generated by a lowercase symbol is prefixed with "AST" in Haskell
-- so the parser called parseProgram would have the type "Parser ASTProgram"

-- the type generated by an uppercase symbol is always ()
-- so the parser called parseTokenProgram would have type "Parser ()"

-- (there needs to be some prefix, in case a rule or token name conflicts
-- with something in the Haskell prelude or something we use internally)

start_symbol
    : WHITESPACE {lexical_token WHITESPACE} EOF
    ;

-- EOF is defined with Parsec: eof

WHITESPACE
    : {WHITESPACE_CHARACTER | COMMENT}
    ;

-- WHITESPACE_CHARACTER is defined with Parsec: oneOf "\t\n\v\f\r "

COMMENT
    : LEFT_BRACE {COMMENT_CHARACTER} RIGHT_BRACE
    ;

-- the braces are done separately (as tokens) to suppress them in the AST
LEFT_BRACE
    : "{"
    ;

RIGHT_BRACE
    : "}"
    ;

-- COMMENT_CHARACTER is defined with Parsec: noneOf "}"

-- longer tokens must be listed first in this list, e.g. ":=" before ":"
lexical_token
    : LEFT_PARENTHESIS
    | RIGHT_PARENTHESIS
    | TIMES
    | PLUS
    | COMMA
    | MINUS
    | ELLIPSIS
    | DOT -- must be after ELLIPSIS
    | DIVIDE_BY
    | ASSIGN
    | COLON -- must be after ASSIGN
    | SEMICOLON
    | LESS_THAN_OR_EQUAL
    | NOT_EQUAL
    | LESS_THAN -- must be after LESS_THAN_OR_EQUAL and NOT_EQUAL
    | EQUAL
    | GREATER_THAN_OR_EQUAL
    | GREATER_THAN -- must be after GREATER_THAN_OR_EQUAL
    | LEFT_BRACKET
    | RIGHT_BRACKET
    -- commented tokens as follows are not recognized by the Parsec lexer,
    -- we get them by matching the "identifier" rule and post-processing it:
    --| AND
    --| ARRAY
    --| BEGIN
    --| BOOLEAN
    --| DIV
    --| DO
    --| DOWN_TO
    --| ELSE
    --| END
    --| FOR
    --| FUNCTION
    --| IF
    --| INTEGER
    --| NOT
    --| OF
    --| OR
    --| PROCEDURE
    --| PROGRAM
    --| REAL
    --| THEN
    --| TO
    --| VAR
    --| WHILE
    | character_string
    | identifier
    | unsigned_real
    | unsigned_integer -- must be after unsigned_real
    ;

LEFT_PARENTHESIS
    : "("
    ;

RIGHT_PARENTHESIS
    : ")"
    ;

TIMES
    : "*"
    ;

PLUS
    : "+"
    ;

COMMA
    : ","
    ;

MINUS
    : "-"
    ;

ELLIPSIS
    : ".."
    ;

DOT
    : "."
    ;

DIVIDE_BY
    : "/"
    ;

ASSIGN
    : ":="
    ;

COLON
    : ":"
    ;

SEMICOLON
    : ";"
    ;

LESS_THAN_OR_EQUAL
    : "<="
    ;

NOT_EQUAL
    : "<>"
    ;

LESS_THAN
    : "<"
    ;

EQUAL
    : "="
    ;

GREATER_THAN_OR_EQUAL
    : ">="
    ;

GREATER_THAN
    : ">"
    ;

LEFT_BRACKET
    : "["
    ;

RIGHT_BRACKET
    : "]"
    ;

-- commented tokens as follows are not recognized by the Parsec lexer,
-- we get them by matching the "identifier" rule and post-processing it:

--AND
--    : "and"
--    ;

--ARRAY
--    : "array"
--    ;

--BEGIN
--    : "begin"
--    ;

--BOOLEAN
--    : "boolean"
--    ;

--DIV
--    : "div"
--    ;

--DO
--    : "do"
--    ;

--DOWN_TO
--    : "downto"
--    ;

--ELSE
--    : "else"
--    ;

--END
--    : "end"
--    ;

--FOR
--    : "for"
--    ;

--FUNCTION
--    : "function"
--    ;

--IF
--    : "if"
--    ;

--INTEGER
--    : "integer"
--    ;

--NOT
--    : "not"
--    ;

--OF
--    : "of"
--    ;

--OR
--    : "or"
--    ;

--PROCEDURE
--    : "procedure"
--    ;

--PROGRAM
--    : "program"
--    ;

--REAL
--    : "real"
--    ;

--THEN
--    : "then"
--    ;

--TO
--    : "to"
--    ;

--VAR
--    : "var"
--    ;

--WHILE
--    : "while"
--    ;

character_string
    : SINGLE_QUOTE {string_element} SINGLE_QUOTE
    ;

-- the quotes are done separately (as tokens) to suppress them in the AST
SINGLE_QUOTE
    : "'"
    ;

string_element
    : "''"
    | string_character
    ;

-- string_character is defined with Parsec: noneOf "'\n"

identifier
    : letter {letter | digit}
    ;

-- letter is defined with Parsec: satisfy (\a -> isLetter a)
-- letters are also converted to lowercase, since Pascal is case insensitive
-- digit is defined with Parsec: satisfy (\a -> isDigit a)

unsigned_integer
    : digit_sequence
    ;

digit_sequence
    : digit {digit}
    ;

unsigned_real
    : digit_sequence DOT digit_sequence [E scale_factor]
    | digit_sequence E scale_factor
    ;

E
    : "e"
    ;

scale_factor
    : [sign] digit_sequence
    ;

sign
    : PLUS
    | MINUS
    ;
