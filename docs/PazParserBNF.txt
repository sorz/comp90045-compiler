-- symbols are converted to camel case which is mandatory for Haskell

-- symbols in lowercase here are prefixed with "parse" in Haskell
-- symbols in uppercase here are prefixed with "parseToken" in Haskell

-- the type generated by a lowercase symbol is prefixed with "AST" in Haskell
-- so the parser called parseProgram would have the type "Parser ASTProgram"

-- the type generated by an uppercase symbol is always ()
-- so the parser called parseTokenProgram would have type "Parser ()"

-- (there needs to be some prefix, in case a rule or token name conflicts
-- with something in the Haskell prelude or something we use internally)

-- note that uppercase/lowercase does not tell you whether the symbol comes
-- from the lexical analysis phase, it only tells you whether there's data

start_symbol
    : program EOF
    ;

-- EOF is defined with Parsec: eof

-- program section

program
    : PROGRAM identifier SEMICOLON variable_declaration_part procedure_declaration_part compound_statement DOT
    ;

procedure_declaration_part
    : {procedure_declaration SEMICOLON}
    ;

-- statements section

statement
    : assignment_statement
    | procedure_statement -- must go after assignment_statement
    | compound_statement
    | if_statement
    | while_statement
    | for_statement
    | empty_statement -- must go at the end
    ;

empty_statement
    :
    ;

assignment_statement
    : (variable_access | identifier) ASSIGN expression
    ;

-- this means the call to a procedure
procedure_statement
    : identifier [actual_parameter_list]
    ;

actual_parameter_list
    : LEFT_PARENTHESIS expression {COMMA expression} RIGHT_PARENTHESIS
    ;

compound_statement
    : BEGIN statement_sequence END
    ;

statement_sequence
    : statement {SEMICOLON statement}
    ;

if_statement
    : IF expression THEN statement [ELSE statement]
    ;

while_statement
    : WHILE expression DO statement
    ;

for_statement
    : FOR identifier ASSIGN expression (TO | DOWN_TO) expression DO statement
    ;

-- expressions section

expression
    : simple_expression [relational_operator simple_expression]
    ;

relational_operator
    : EQUAL
    | NOT_EQUAL
    | LESS_THAN
    | GREATER_THAN
    | LESS_THAN_OR_EQUAL
    | GREATER_THAN_OR_EQUAL
    ;

simple_expression
    : [sign] term {adding_operator term}
    ;

adding_operator
    : PLUS
    | MINUS
    | OR
    ;

term
    : factor {multiplying_operator factor}
    ;

multiplying_operator
    : TIMES
    | DIVIDE_BY
    | DIV
    | AND
    ;

factor
    : unsigned_constant
    | variable_access
    | LEFT_PARENTHESIS expression RIGHT_PARENTHESIS
    | NOT factor
    ;

unsigned_constant
    : unsigned_number
    | character_string
    ;

unsigned_number
    : unsigned_integer
    | unsigned_real
    ;

variable_access
    : indexed_variable
    | identifier -- must be after indexed_variable
    ;

indexed_variable
    : identifier LEFT_BRACKET expression RIGHT_BRACKET
    ;

-- procedures

procedure_declaration
    : PROCEDURE identifier [formal_parameter_list] SEMICOLON variable_declaration_part compound_statement
    ;

formal_parameter_list
    : LEFT_PARENTHESIS formal_parameter_section {SEMICOLON formal_parameter_section} RIGHT_PARENTHESIS
    ;

formal_parameter_section
    : [VAR] identifier_list COLON type_denoter
    ;

identifier_list
    : identifier {COMMA identifier}
    ;

-- variables section

variable_declaration_part
    : [VAR variable_declaration SEMICOLON {variable_declaration SEMICOLON}]
    ;

variable_declaration
    : identifier_list COLON type_denoter
    ;

type_denoter
    : type_identifier
    | array_type
    ;
   
type_identifier
    : INTEGER
    | REAL
    | BOOLEAN
    ;

array_type
    : ARRAY LEFT_BRACKET subrange_type RIGHT_BRACKET OF type_identifier
    ;

subrange_type
    : constant ELLIPSIS constant
    ;

constant
    : [sign] unsigned_integer
    ;

sign
    : PLUS
    | MINUS
    ;
